<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    html,
    body {
      margin: 0;
    }

    .canvas-container,
    .canvas2-container {
      display: none;
      border: 1px solid #ddd;
    }
  </style>
</head>
<body>
  <!-- 
    0. input file => 读取图片
    1. canvas画布 => 自适应 => 图片的大小就是画布的大小
    2. 绘制图片 => drawImage
    3. 蒙层    => 黑色半透明的层
    4. 截图的矩形 => 在蒙层上方鼠标移动的范围内进行图片再绘制
    5. 获取当前图片截图后的数据
    6. 放入另一个canvas
   -->

  <div>
    <input type="file" id="imageFile" accept="image/*" />
  </div>

  <div class="canvas-container">
    <canvas id="can"></canvas>
  </div>

  <div class="canvas2-container">
    <canvas id="can2"></canvas>
  </div>

  <script>
    const oContainer = document.querySelector('.canvas-container');
    const oContainer2 = document.querySelector('.canvas2-container');
    const oImageFile = document.querySelector('#imageFile');
    const oCan = document.getElementById('can');
    const oCan2 = document.getElementById('can2');
    const ctx = oCan.getContext('2d');
    const ctx2 = oCan2.getContext('2d');

    const oImage = new Image();
    let initPos = [];
    let screenShotData = [];
    const MASK_OPACITY = .5;

    const init = () => {
      bindEvent();
    }

    function bindEvent () {
      oImageFile.addEventListener('change', handleFileChange, false);
      oCan.addEventListener('mousedown', handleCanvasMouseDown, false);
    }

    function handleCanvasMouseDown (e) {
      initPos = [ e.offsetX, e.offsetY ];

      oCan.addEventListener('mousemove', handleCanvasMouseMove, false);
      oCan.addEventListener('mouseup', handleCanvasMouseUp, false);
    }

    function handleCanvasMouseMove (e) {
      const endX = e.offsetX;
      const endY = e.offsetY;
      const [ startX, startY ] = initPos;
      const rectWidth = endX - startX;
      const rectHeight = endY - startY;
      const { width, height } = oCan;

      screenShotData = [ startX, startY, rectWidth, rectHeight ];

      ctx.clearRect(0, 0, width, height);
      drawImageMask(0, 0, width, height, MASK_OPACITY);
      drawScreenShot(width, height, rectWidth, rectHeight);
    }

    function handleCanvasMouseUp () {
      oCan.removeEventListener('mousemove', handleCanvasMouseMove, false);
      oCan.removeEventListener('mouseup', handleCanvasMouseUp, false);
      drawScreenShotImage(screenShotData);
    }

    function handleFileChange (e) {
      const file = e.target.files[0];
      const reader = new FileReader();

      reader.readAsDataURL(file);
      reader.onload = function (e) {
        const data = e.target.result;
        oImage.src = data;

        oImage.onload = function () {
          const { width, height } = this;
          generateCanvas(oContainer, oCan, width, height);
          ctx.drawImage(oImage, 0, 0, width, height);
          drawImageMask(0, 0, width, height, MASK_OPACITY);
        }
      }
    }

    function generateCanvas (container, canvas, width, height) {
      container.style.width = width + 'px';
      container.style.height = height + 'px';
      canvas.width = width;
      canvas.height = height;
      container.style.display = 'block';
    }

    function drawImageMask (x, y, width, height, opacity) {
      ctx.fillStyle = `rgba(0, 0, 0, ${ opacity })`;
      ctx.fillRect(0, 0, width, height);
    }

    function drawScreenShot (canWidth, canHeight, rectWidth, rectHeight) {
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillStyle = '#000';
      ctx.fillRect(...initPos, rectWidth, rectHeight);

      ctx.globalCompositeOperation = 'destination-over';
      ctx.drawImage(oImage, 0, 0, canWidth, canHeight, 0, 0, canWidth, canHeight);
    }

    function drawScreenShotImage (screenShotData) {
      const data = ctx.getImageData(...screenShotData);
      generateCanvas(oContainer2, oCan2, screenShotData[2], screenShotData[3]);
      ctx2.clearRect(...screenShotData);
      ctx2.putImageData(data, 0, 0);
    }

    init();
  </script>

</body>
</html>